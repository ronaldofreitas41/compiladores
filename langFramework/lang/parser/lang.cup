package lang.parser;

import java_cup.runtime.*;
import lang.ast.*;
import lang.ast.command.*;
import lang.ast.expr.*;
import lang.ast.types.*;
import java.util.ArrayList;

class LangParser;
parser code {:
    LangLexer s;
    public LangParser(LangLexer s){ this.s = s; }
:}

init with {: :};
scan with {: return s.nextToken(); :};

/* Tokens */
terminal PLUS, MINUS, TIMES, DIVIDE, MOD;
terminal EQUAL, DIFFERENT, LESS, GREATER;
terminal AND, NOT, DCOLON, ASSIGN;
terminal LP, RP, LBRACE, RBRACE, LBRACK, RBRACK; // Tokens para colchetes
terminal SEMICOLON, COMMA, COLON, DOT;
terminal INT, FLOAT, CHAR;
terminal TRUE, FALSE, NULL;
terminal ID, TYPE_ID;
terminal IF, ELSE, ITERATE, RETURN, READ, PRINT, NEW;

/* Não-terminais */
non terminal Prog prog;
non terminal Data data, data_list;
non terminal Func func, func_list;
non terminal Decl decl, decl_list;
non terminal Type type, btype, type_list;
non terminal Params params;
non terminal StmtBlock stmtBlock;
non terminal LoopCond loopCond;
non terminal LValue lvalue;
non terminal Exps exps;
non terminal Block block;
non terminal Cmd cmd;

/* Precedências */
precedence left AND;
precedence left EQUAL, DIFFERENT;
precedence left LESS, GREATER;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence right NOT;

/* Regras */
prog ::= data_list:dl func_list:fl {: RESULT = new Program(dl, fl); :};

data_list ::= data:d {: RESULT = new DataList(d); :}
            | data_list:dl data:d {: RESULT = dl.add(d); :};

data ::= TYPE_ID:t LBRACE decl_list:dl RBRACE {: RESULT = new DataType(t, dl); :};

decl_list ::= decl:d {: RESULT = new DeclList(d); :}
            | decl_list:dl decl:d {: RESULT = dl.add(d); :};

decl ::= ID:i DCOLON type:t SEMICOLON {: RESULT = new Decl(sleft, sright, i, t); :};

func_list ::= func:f {: RESULT = new FuncList(f); :}
            | func_list:fl func:f {: RESULT = fl.add(f); :};

func ::= ID:i LP params:p RP [COLON type_list:tl] block:b {: RESULT = new Function(sleft, sright, i, p, tl, b); :};

params ::= param_list:pl {: RESULT = new Params(pl); :};

param_list ::= param:p {: RESULT = new ParamList(p); :}
             | param_list:pl COMMA param:p {: RESULT = pl.add(p); :};

param ::= ID:i DCOLON type:t {: RESULT = new Param(sleft, sright, i, t); :};

type_list ::= type:t {: RESULT = new TypeList(t); :}
            | type_list:tl COMMA type:t {: RESULT = tl.add(t); :};

type ::= type:t LBRACK RBRACK {: RESULT = new ArrayType(t); :}
        | btype:b {: RESULT = b; :};

btype ::= TYPE_ID:t {: RESULT = new TypeID(t); :}
        | INT {: RESULT = new IntType(); :}
        | CHAR {: RESULT = new CharType(); :}
        | BOOL {: RESULT = new BoolType(); :}
        | FLOAT {: RESULT = new FloatType(); :};

block ::= LBRACE stmtBlock:sb RBRACE {: RESULT = sb; :};

stmtBlock ::= block:b {: RESULT = b; :}
            | cmd:c {: RESULT = new StmtBlock(c); :};

cmd ::= IF LP expr:e RP stmtBlock:s {: RESULT = new If(sleft, sright, e, s); :}
      | IF LP expr:e RP stmtBlock:s1 ELSE stmtBlock:s2 {: RESULT = new IfElse(sleft, sright, e, s1, s2); :}
      | ITERATE LP loopCond:lc RP stmtBlock:s {: RESULT = new Iterate(sleft, sright, lc, s); :}
      | READ lvalue:lv SEMICOLON {: RESULT = new Read(sleft, sright, lv); :}
      | PRINT expr:e SEMICOLON {: RESULT = new Print(sleft, sright, e); :}
      | RETURN exps:e SEMICOLON {: RESULT = new Return(sleft, sright, e); :}
      | lvalue:lv ASSIGN expr:e SEMICOLON {: RESULT = new Assign(sleft, sright, lv, e); :}
      | ID:i LP exps:e RP [LESS lvalue_list:lvs GREATER] SEMICOLON {: RESULT = new FunctionCall(sleft, sright, i, e, lvs); :};

loopCond ::= ID:i COLON expr:e {: RESULT = new LoopID(sleft, sright, i, e); :}
           | expr:e {: RESULT = new LoopExpr(e); :};

lvalue_list ::= lvalue:lv {: RESULT = new LValueList(lv); :}
              | lvalue_list:lvs COMMA lvalue:lv {: RESULT = lvs.add(lv); :};

expr ::= expr:e1 AND expr:e2 {: RESULT = new And(sleft, sright, e1, e2); :}
       | expr:e1 EQUAL expr:e2 {: RESULT = new Equal(sleft, sright, e1, e2); :}
       | expr:e1 DIFFERENT expr:e2 {: RESULT = new Diff(sleft, sright, e1, e2); :}
       | expr:e1 LESS expr:e2 {: RESULT = new Less(sleft, sright, e1, e2); :}
       | expr:e1 GREATER expr:e2 {: RESULT = new Greater(sleft, sright, e1, e2); :}
       | expr:e1 PLUS expr:e2 {: RESULT = new Plus(sleft, sright, e1, e2); :}
       | expr:e1 MINUS expr:e2 {: RESULT = new Sub(sleft, sright, e1, e2); :}
       | expr:e1 TIMES expr:e2 {: RESULT = new Times(sleft, sright, e1, e2); :}
       | expr:e1 DIVIDE expr:e2 {: RESULT = new Div(sleft, sright, e1, e2); :}
       | expr:e1 MOD expr:e2 {: RESULT = new Mod(sleft, sright, e1, e2); :}
       | NOT expr:e {: RESULT = new Not(sleft, sright, e); :}
       | MINUS expr:e {: RESULT = new Neg(sleft, sright, e); :}
       | LP expr:e RP {: RESULT = e; :}
       | INT:n {: RESULT = new IntLit(n); :}
       | FLOAT:n {: RESULT = new FloatLit(n); :}
       | TRUE {: RESULT = new BoolLit(true); :}
       | FALSE {: RESULT = new BoolLit(false); :}
       | NULL {: RESULT = new NullLit(); :}
       | CHAR:c {: RESULT = new CharLit(c); :}
       | lvalue:lv {: RESULT = lv; :}
       | NEW type:t LBRACK expr:e RBRACK {: RESULT = new NewArray(sleft, sright, t, e); :}
       | ID:i LP exps:e RP {: RESULT = new Call(sleft, sright, i, e); :};

lvalue ::= ID:i {: RESULT = new LValueID(i); :}
         | lvalue:lv LBRACK expr:e RBRACK {: RESULT = new LValueArray(lv, e); :}
         | lvalue:lv DOT ID:i {: RESULT = new LValueField(lv, i); :};

exps ::= expr:e {: RESULT = new ExprList(e); :}
       | exps:es COMMA expr:e {: RESULT = es.add(e); :};