package lang.parser;

import java_cup.runtime.*;
import lang.ast.*;
import lang.ast.decl.*;
import lang.ast.command.*;
import lang.ast.expr.*;
import lang.ast.types.*;
import java.util.ArrayList;

class LangParser;
parser code {:
    // Conecta o parser ao lexer
    LangLexer s;
    public LangParser(LangLexer s){ this.s=s; }
:}

init with {:               :};
scan with {: return s.nextToken(); :};

/* Definição dos tokens*/                                    /* Descrição dos tokens    */
terminal PLUS, MINUS, TIMES, DIVIDE, MOD;                    // Operadores aritméticos ('+', '-', '*', '/', '%')
terminal TYBOOL, TYFLOAT, TYINT, TYID, TYNULL,TYCHAR;               // Tipos de dados (bool, float, int, id, null)
terminal EQUAL, DIFFERENT, LESS, GREATER;                    // Operadores relacionais ('==', '!=', '<', '>')
terminal AND, NOT, DCOLON, ASSIGN;                           // Operadores lógicos e de atribuição ('&&', '!', ':', '=')
terminal LP, RP, LBRACE, RBRACE, LBRACK, RBRACK;             // '(', ')', '{', '}'
terminal LBRACKET, RBRACKET;                                 // '[' e ']'
terminal SEMICOLON, COMMA, COLON, DOT, QUOTATION_MARKS;      // ';', ',', ':', '.', '"'
terminal Integer INT;                                        // Número inteiro
terminal Float FLOAT;                                        // Número real
terminal String ID, CHAR;                                    // Identificador, caractere
terminal Boolean BOOL, TRUE, FALSE, NULL;                    // Booleano, true, false, null
terminal IDENTIFIER, TYPE_ID;                                // Identificador, tipo
terminal ESCAPE, ASCII;                                      // Caracteres de escape, ASCII
terminal ARR;                                                // Array
terminal IF, ELSE, ITERATE, RETURN, READ, PRINT, NEW;        // Comandos

/* Não-terminais */
non terminal Prog prog;
non terminal Exp expr; 
non terminal LType type;
non terminal LType bType;
non terminal Cmd cmd;
non terminal Node node, stmt, stmtList;
non terminal ArrayList<Cmd> cmdList;
non terminal ArrayList<Decl> declList;

/* Precedência e associatividade dos operadores */
precedence left AND;
precedence left EQUAL, DIFFERENT;
precedence left LESS, GREATER;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence right NOT;

/* Regras da gramática */

// Programa

// Data

// Fun Def

// Decl

// Type não sei a maneira correta de implementar esse
type ::= bType:t LBRACKET RBRACKET  {: RESULT = new ArrayType(t);  :}
      | bType:t          {: RESULT = new BasicType(t); :}
     ;

// Comandos


// Bind
bind ::= LP ID:id DCOLON bType:t RP {: RESULT = new Bind(tleft,tright,ty,new Var(vleft, vright, v)); :};

// statements

// bType
bType ::= TYBOOL:s                   {: RESULT = new TyBool(sleft, sright);     :}
       | TYINT:s                     {: RESULT = new TyInt(sleft, sright); :}
       | TYID:s                      {: RESULT = new TyId(sleft, sright);  :}
       | TYCHAR:s                    {: RESULT = new TyChar(sleft, sright);  :}
       | TYNULL:s                    {: RESULT = new TyNull(sleft, sright);  :}
       | TYFLOAT:s                   {: RESULT = new TyFloat(sleft, sright); :}
       ;

// Comandos

// Expressões
expr ::= expr:e1 AND expr:e2       {: RESULT = new And(sleft, sright, e1, e2);     :}
       | expr:e1 EQUAL expr:e2     {: RESULT = new Equal(sleft, sright, e1, e2);   :}
       | expr:e1 DIFFERENT expr:e2 {: RESULT = new Diff(sleft, sright, e1, e2);    :}
       | expr:e1 LESS expr:e2      {: RESULT = new Less(sleft, sright, e1, e2);    :}
       | expr:e1 GREATER expr:e2   {: RESULT = new Greater(sleft, sright, e1, e2); :}
       | expr:e1 PLUS expr:e2      {: RESULT = new Plus(sleft, sright, e1, e2);    :}
       | expr:e1 MINUS expr:e2     {: RESULT = new Sub(sleft, sright, e1, e2);     :}
       | expr:e1 TIMES expr:e2     {: RESULT = new Times(sleft, sright, e1, e2);   :}
       | expr:e1 DIVIDE expr:e2    {: RESULT = new Div(sleft, sright, e1, e2);     :}
       | expr:e1 MOD expr:e2       {: RESULT = new Mod(sleft, sright, e1, e2);     :}
       | NOT expr:e                {: RESULT = new Not(sleft, sright, e);          :}
       | MINUS expr:e              {: RESULT = new Neg(sleft, sright, e);          :}
       | LP expr:e RP              {: RESULT = e;                                  :}
       | INT:n                     {: RESULT = new IntLit(n);                      :}
       | FLOAT:n                   {: RESULT = new FloatLit(n);                    :}
       | TRUE:n                    {: RESULT = new BoolLit(true);                  :}
       | FALSE:n                   {: RESULT = new BoolLit(false);                 :}
       | NULL:n                    {: RESULT = new NullLit();                      :}
       | CHAR:c                    {: RESULT = new CharLit(c);                     :}
       ;