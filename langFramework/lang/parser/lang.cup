package lang.parser;

import java_cup.runtime.*;
import lang.ast.*;
import lang.ast.decl.*;
import lang.ast.command.*;
import lang.ast.expr.*;
import lang.ast.types.*;
import java.util.ArrayList;

class LangParser;
parser code {:
    // Conecta o parser ao lexer
    LangLexer s;
    public LangParser(LangLexer s){ this.s=s; }
:}

init with {:               :};
scan with {: return s.nextToken(); :};

/* Definição dos tokens*/                                    /* Descrição dos tokens    */
terminal PLUS, MINUS, TIMES, DIVIDE, MOD;                    // Operadores aritméticos ('+', '-', '*', '/', '%')
terminal TYBOOL, TYFLOAT, TYINT, TYID, TYNULL,TYCHAR;        // Tipos de dados (bool, float, int, id, null)
terminal EQUAL, DIFFERENT, LESS, GREATER;                    // Operadores relacionais ('==', '!=', '<', '>')
terminal AND, NOT, DCOLON, ASSIGN;                           // Operadores lógicos e de atribuição ('&&', '!', ':', '=')
terminal LP, RP, LBRACE, RBRACE;                             // '(', ')', '{', '}'
terminal LBRACKET, RBRACKET;                                 // '[' e ']'
terminal SEMICOLON, COMMA, COLON;                            // ';', ',', ':', '.',
//terminal QUOTATION_MARKS, DOT;                             // '"', '.'
terminal Integer INT;                                        // Número inteiro
terminal Float FLOAT;                                        // Número real
terminal String ID, CHAR;                                    // Identificador, caractere
terminal Boolean TRUE, FALSE, NULL;                          // Booleano, true, false
//terminal Boolean BOOL;                                     // Booleano, true, false, null
//terminal ESCAPE, ASCII;                                    // Caracteres de escape, ASCII
//terminal ARR, NEW;                                         // Array, new
terminal IF, ELSE, ITERATE, RETURN, READ, PRINT;             // Comandos
terminal DATA;        

/* Não-terminais */
non terminal Prog prog;
non terminal Data data;
non terminal ArrayList<Data> dataList;
non terminal FunDef func;
non terminal ArrayList<FunDef> funcList;
non terminal Exp expr;
non terminal ArrayList<Exp> expList;
non terminal LType type;
non terminal ArrayList<LType> typeList;
non terminal LType bType;
non terminal Cmd cmd;
non terminal ArrayList<Cmd> cmdList;
non terminal Decl decl;
non terminal ArrayList<Decl> declList;
non terminal Block block;
non terminal StmtBlock stmtBlock;
non terminal LValue lvalue;
non terminal Exps exps;
non terminal LoopCond loopCond;
non terminal Bind param;
non terminal ArrayList<Bind> paramList;
non terminal Bind bind;
non terminal ArrayList<Bind> bindList;


/* Precedência e associatividade dos operadores */
precedence left AND;
precedence left EQUAL, DIFFERENT;
precedence left LESS, GREATER;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence right NOT;

/* Regras da gramática */

// Programa
prog ::= dataList:d funcList:f {: RESULT = new Program(dleft,dright,d,f); :};

//Data List
dataList ::= dataList:dl data:d {: dl.add(d); RESULT = dl; :}
       |  {: RESULT = new ArrayList<Data>(); :}
       ;

// Data
data ::= DATA:dt TYID:id LBRACE decl:d RBRACE {: RESULT = new Data(sleft, sright, id, d); :};

//Function List
funcList ::= funcList:fl func:f {: fl.add(f); RESULT = fl; :}
       |  {: RESULT = new ArrayList<FunDef>(); :};

// ParamList
paramList ::= bindList:l {: RESULT = l;:}
        |                {: RESULT =  new ArrayList<Bind>(); :}
        ;

// BindList
bindList ::= bind:b  COMMA bindList:bl {: bl.add(b); RESULT = bl;:}
          |  bind:b                  {: ArrayList<Bind> arr = new ArrayList<Bind>();
                                        arr.add(b);
                                        RESULT = arr; :}
          ;
// Bind
bind ::= type:ty COLON:t ID:v {: RESULT = new Bind(tleft,tright,ty,new Var(vleft, vright, v)); :}
     ;

// Param
param ::= ID:i DCOLON type:t {: RESULT = new Param(sleft, sright, i, t); :};

//Ta dando erro aqui
//func ::= ID:i LP paramList:params RP COLON typeList:tl block:b {: RESULT = new FunDef(ileft, iright, i, params, tl, b); :}
//       |  ID:i LP paramList:params RP block:b {: RESULT = new FunDef(ileft, iright, i, params, null, b); :}
//       |  ID:i LP RP COLON typeList:tl block:b {: RESULT = new FunDef(ileft, iright, i, null, tl, b); :}
//       |  ID:i LP RP block:b {: RESULT = new FunDef(ileft, iright, i, null, null, b); :};

 
// Decl
decl ::= ID:i DCOLON type:t SEMICOLON {: RESULT = new Decl(tleft, tright, i, t); :};

// DeclList
declList ::= declList:dl decl:d {: dl.add(d); RESULT = dl; :}
        |  {: RESULT = new ArrayList<Decl>(); :}
        ;

// Type 
type ::= type:t LBRACKET RBRACKET   {:                                  :}
      | bType:b                     {: RESULT = b;                       :}
     ;

// Type List
typeList ::= typeList:tl COMMA type:t {: tl.add(t); RESULT = tl; :}
       |  type:t {: List<Type> l = new ArrayList<Type>(); l.add(t); RESULT = l; :};

// bType
bType ::= TYBOOL:s                   {: RESULT = new TyBool(sleft, sright);  :}
       | TYINT:s                     {: RESULT = new TyInt(sleft, sright);   :}
       | TYID:s                      {: RESULT = new TyId(sleft, sright);    :}
       | TYCHAR:s                    {: RESULT = new TyChar(sleft, sright);  :}
       | TYNULL:s                    {: RESULT = new TyNull(sleft, sright);  :}
       | TYFLOAT:s                   {: RESULT = new TyFloat(sleft, sright); :}
       ;

// Statements
stmtBlock ::= block:bk {: RESULT = new StmtBlock(bkleft,bkright,bk.getCommands()); :}
       | cmd:c {: RESULT = new StmtBlock(cleft,cright,Arrays.asList(c)); :};


// Comandos
cmd ::= IF:c LP expr:e RP stmtBlock:s                       {: RESULT = new If(cleft, cright, e, s);          :}
      | IF:c LP expr:e RP stmtBlock:s1 ELSE stmtBlock:s2    {: RESULT = new IfElse(cleft, cright, e, s1, s2); :}
      | ITERATE:c LP loopCond:lc RP stmtBlock:s             {: RESULT = new Iterate(cleft, cright, lc, s);    :}
      | READ:c lvalue:lv SEMICOLON                          {: RESULT = new Read(cleft, cright, lv);          :}
      | PRINT:c expr:e SEMICOLON                            {: RESULT = new Print(cleft, cright, e);          :}
      | RETURN:c exps:e SEMICOLON                           {: RESULT = new Return(cleft, cright, e);         :}
      | lvalue:lv ASSIGN:c expr:e SEMICOLON                 {: RESULT = new Assign(cleft, cright, lv, e);     :}
      | ID:i LP expList:el RP SEMICOLON                   {: RESULT = new FuncCall(i, el);                  :};

// Command List
cmdList ::= cmdList:cl cmd:c {: cl.add(c); RESULT = cl; :}
       | {: RESULT = new ArrayList<Cmd>(); :};

// Block
block ::= LBRACE cmdList RBRACE {: RESULT = new Block(sleft, sright, cmd); :};

// stmtBlock
stmtBlock ::= block:b {: RESULT = b; :}
            | cmd:c   {: RESULT = c; :};


// Expressões
expr ::= expr:e1 AND:s expr:e2        {: RESULT = new And(sleft, sright, e1, e2);     :}
       | expr:e1 EQUAL:s expr:e2      {: RESULT = new Equal(sleft, sright, e1, e2);   :}
       | expr:e1 DIFFERENT:s expr:e2  {: RESULT = new Diff(sleft, sright, e1, e2);    :}
       | expr:e1 LESS:s expr:e2       {: RESULT = new Less(sleft, sright, e1, e2);    :}
       | expr:e1 GREATER:s expr:e2    {: RESULT = new Greater(sleft, sright, e1, e2); :}
       | expr:e1 PLUS:s expr:e2       {: RESULT = new Plus(sleft, sright, e1, e2);    :}
       | expr:e1 MINUS:s expr:e2      {: RESULT = new Sub(sleft, sright, e1, e2);     :}
       | expr:e1 TIMES:s expr:e2      {: RESULT = new Times(sleft, sright, e1, e2);   :}
       | expr:e1 DIVIDE:s expr:e2     {: RESULT = new Div(sleft, sright, e1, e2);     :}
       | expr:e1 MOD:s expr:e2        {: RESULT = new Mod(mleft, mright, e1, e2);     :}
       | NOT:n expr:e                 {: RESULT = new Not(nleft, nright, e);          :}
       | MINUS expr:e                 {: RESULT = new Neg(sleft, sright, e);          :}
       | LP expr:e RP                 {: RESULT = e;                                  :}
       | INT:n                        {: RESULT = new IntLit(n);                      :}
       | FLOAT:n                      {: RESULT = new FloatLit(n);                    :}
       | TRUE:n                       {: RESULT = new BoolLit(true);                  :}
       | FALSE:n                      {: RESULT = new BoolLit(false);                 :}
       | NULL:n                       {: RESULT = new NullLit();                      :}
       | CHAR:c                       {: RESULT = new CharLit(c);                     :}
       ;

//Exp List
expList ::= expList:el COMMA expr:e {: el.add(e); RESULT = el; :}
          | expr:e {: ArrayList<Exp> l = new ArrayList<>(); l.add(e); RESULT = l; :};
