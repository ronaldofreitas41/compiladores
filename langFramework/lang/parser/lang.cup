package lang.parser;

import java_cup.runtime.*;
import lang.ast.*;
import lang.ast.decl.*;
import lang.ast.command.*;
import lang.ast.expr.*;
import lang.ast.types.*;
import java.util.ArrayList;

class LangParser;
parser code {:
    // Conecta o parser ao lexer
    LangLexer s;
    public LangParser(LangLexer s){ this.s=s; }
:}

init with {:               :};
scan with {: return s.nextToken(); :};

/* Definição dos tokens*/                                    /* Descrição dos tokens    */
terminal PLUS, MINUS, TIMES, DIVIDE, MOD;                    // Operadores aritméticos ('+', '-', '*', '/', '%')
terminal TYBOOL, TYFLOAT, TYINT, TYID, TYNULL,TYCHAR;               // Tipos de dados (bool, float, int, id, null)
terminal EQUAL, DIFFERENT, LESS, GREATER;                    // Operadores relacionais ('==', '!=', '<', '>')
terminal AND, NOT, DCOLON, ASSIGN;                           // Operadores lógicos e de atribuição ('&&', '!', ':', '=')
terminal LP, RP, LBRACE, RBRACE, LBRACK, RBRACK;             // '(', ')', '{', '}'
terminal LBRACKET, RBRACKET;                                 // '[' e ']'
terminal SEMICOLON, COMMA, COLON, DOT, QUOTATION_MARKS;      // ';', ',', ':', '.', '"'
terminal Integer INT;                                        // Número inteiro
terminal Float FLOAT;                                        // Número real
terminal String ID, CHAR;                                    // Identificador, caractere
terminal Boolean BOOL, TRUE, FALSE, NULL;                    // Booleano, true, false, null
terminal IDENTIFIER, TYPE_ID;                                // Identificador, tipo
terminal ESCAPE, ASCII;                                      // Caracteres de escape, ASCII
terminal ARR;                                                // Array
terminal IF, ELSE, ITERATE, RETURN, READ, PRINT, NEW;        // Comandos
terminal DATA;        

/* Não-terminais */
non terminal Prog prog;
non terminal Data data;
non terminal ArrayList<Data> dataList;
non terminal FunDef func;
non terminal ArrayList<FunDef> funcList;
non terminal Exp expr;
non terminal LType type;
non terminal ArrayList<LType> typeList;
non terminal LType bType;
non terminal Cmd cmd;
non terminal ArrayList<Cmd> cmdList;
non terminal Node node;
non terminal Decl decl;
non terminal ArrayList<Decl> declList;
non terminal Exp program;
non terminal Block block;
non terminal StmtBlock stmtBlock;
non terminal LValue lvalue;
non terminal Exps exps;
non terminal LValueList lvalue_list;
non terminal LoopCond loopCond;
non terminal ArrayList<Bind> paramList;
non terminal Bind bind;
non terminal ArrayList<Bind> bindList;


/* Precedência e associatividade dos operadores */
precedence left AND;
precedence left EQUAL, DIFFERENT;
precedence left LESS, GREATER;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence right NOT;

/* Regras da gramática */

// Programa
prog ::= dataList:d funcList:f {: RESULT = new Program(dleft,dright,d,f); :};

//Data List
dataList ::= dataList:dl data:d {: dl.add(d); RESULT = dl; :}
       |  {: RESULT = new ArrayList<Data>(); :}
       ;

// Data
data ::= DATA:dt TYID:id LBRACE decl:d RBRACE {: RESULT = new Data(sleft, sright, id, d); :};

//Function List
funcList ::= funcList:fl func:f {: fl.add(f); RESULT = fl; :}
       |  {: RESULT = new ArrayList<FunDef>(); :};

// ParamList
paramList ::= bindList:l {: RESULT = l;:}
        |                {: RESULT =  new ArrayList<Bind>(); :}
        ;

// BindList
bindList ::= bind:b  COMMA bindList:bl {: bl.add(b); RESULT = bl;:}
          |  bind:b                  {: ArrayList<Bind> arr = new ArrayList<Bind>();
                                        arr.add(b);
                                        RESULT = arr; :}
          ;
// Bind
bind ::= type:ty COLON:t ID:v {: RESULT = new Bind(tleft,tright,ty,new Var(vleft, vright, v)); :}
     ;

// Param
param ::= ID:i DCOLON type:t {: RESULT = new Param(sleft, sright, i, t); :};

//Ta dando erro aqui
//func ::= ID:i LP paramList:params RP COLON typeList:tl block:b {: RESULT = new FunDef(ileft, iright, i, params, tl, b); :}
//       |  ID:i LP paramList:params RP block:b {: RESULT = new FunDef(ileft, iright, i, params, null, b); :}
//       |  ID:i LP RP COLON typeList:tl block:b {: RESULT = new FunDef(ileft, iright, i, null, tl, b); :}
//       |  ID:i LP RP block:b {: RESULT = new FunDef(ileft, iright, i, null, null, b); :};

 
// Decl
decl ::= ID:i DCOLON type:t SEMICOLON {: RESULT = new Decl(tleft, tright, i, t); :};

// DeclList
declList ::= declList:dl decl:d {: dl.add(d); RESULT = dl; :}
        |  {: RESULT = new ArrayList<Decl>(); :}
        ;

// Type 
type ::= type:t LBRACKET RBRACKET   {:                                  :}
      | bType:b                     {: RESULT = b                       :}
     ;

// bType
bType ::= TYBOOL:s                   {: RESULT = new TyBool(sleft, sright);  :}
       | TYINT:s                     {: RESULT = new TyInt(sleft, sright);   :}
       | TYID:s                      {: RESULT = new TyId(sleft, sright);    :}
       | TYCHAR:s                    {: RESULT = new TyChar(sleft, sright);  :}
       | TYNULL:s                    {: RESULT = new TyNull(sleft, sright);  :}
       | TYFLOAT:s                   {: RESULT = new TyFloat(sleft, sright); :}
       ;

// Comandos

// statements


// Comandos
cmd ::= IF LP expr:e RP stmtBlock:s                     {: RESULT = new If(sleft, sright, e, s); :}
      | IF LP expr:e RP stmtBlock:s1 ELSE stmtBlock:s2  {: RESULT = new IfElse(sleft, sright, e, s1, s2); :}
      | ITERATE LP loopCond:lc RP stmtBlock:s           {: RESULT = new Iterate(sleft, sright, lc, s); :}
      | READ lvalue:lv SEMICOLON                        {: RESULT = new Read(sleft, sright, lv); :}
      | PRINT expr:e SEMICOLON                          {: RESULT = new Print(sleft, sright, e); :}
      | RETURN exps:e SEMICOLON                         {: RESULT = new Return(sleft, sright, e); :}
      | lvalue:lv ASSIGN expr:e SEMICOLON               {: RESULT = new Assign(sleft, sright, lv, e); :};

// Command List
cmdList ::= cmdList:cl cmd:c {: cl.add(c); RESULT = cl; :}
       | {: RESULT = new ArrayList<Cmd>(); :};

// Definição de bloco(Incompleto) Falta ajustar o {cmd}
block ::= LBRACE cmdList RBRACE {: RESULT = new Block(sleft, sright, cmd); :};

// stmtBlock
stmtBlock ::= block:b {: RESULT = b; :}
            | cmd:c   {: RESULT = c; :};


// Expressões
expr ::= expr:e1 AND expr:e2       {: RESULT = new And(sleft, sright, e1, e2);     :}
       | expr:e1 EQUAL expr:e2     {: RESULT = new Equal(sleft, sright, e1, e2);   :}
       | expr:e1 DIFFERENT expr:e2 {: RESULT = new Diff(sleft, sright, e1, e2);    :}
       | expr:e1 LESS expr:e2      {: RESULT = new Less(sleft, sright, e1, e2);    :}
       | expr:e1 GREATER expr:e2   {: RESULT = new Greater(sleft, sright, e1, e2); :}
       | expr:e1 PLUS expr:e2      {: RESULT = new Plus(sleft, sright, e1, e2);    :}
       | expr:e1 MINUS expr:e2     {: RESULT = new Sub(sleft, sright, e1, e2);     :}
       | expr:e1 TIMES expr:e2     {: RESULT = new Times(sleft, sright, e1, e2);   :}
       | expr:e1 DIVIDE expr:e2    {: RESULT = new Div(sleft, sright, e1, e2);     :}
       | expr:e1 MOD expr:e2       {: RESULT = new Mod(sleft, sright, e1, e2);     :}
       | NOT expr:e                {: RESULT = new Not(sleft, sright, e);          :}
       | MINUS expr:e              {: RESULT = new Neg(sleft, sright, e);          :}
       | LP expr:e RP              {: RESULT = e;                                  :}
       | INT:n                     {: RESULT = new IntLit(n);                      :}
       | FLOAT:n                   {: RESULT = new FloatLit(n);                    :}
       | TRUE:n                    {: RESULT = new BoolLit(true);                  :}
       | FALSE:n                   {: RESULT = new BoolLit(false);                 :}
       | NULL:n                    {: RESULT = new NullLit();                      :}
       | CHAR:c                    {: RESULT = new CharLit(c);                     :}
       ;